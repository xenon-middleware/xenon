// Images: directories needed for integration tests
// LinkedHashMap, so the keySet order is fixed
ext.dockerDirectories = [
    'alpine-base': 'xenon-alpine-base',
    'phusion-base': 'xenon-phusion-base',
    'ftp': 'xenon-ftp',
    'gridengine': 'xenon-gridengine',
    'gridengine-exec': 'xenon-gridengine-exec',
    'slurm': 'xenon-slurm',
    'ssh': 'xenon-ssh',
    'torque': 'xenon-torque' ,
    'test': '.'
]
ext.dockerImages = ext.dockerDirectories.keySet()
// Filter images according to *ftp or *grid*
if (project.hasProperty("docker.filter")) {
    def filter = project.property("docker.filter")
    // Wildcard syntax
    filter = filter.replaceAll(/\*/, ".*").replaceAll(/\?/, ".?")
    ext.dockerImages = ext.dockerImages.findAll { it =~ filter }
}

ext.dockerDir = 'src/integrationTest/docker'

// UID in docker image
ext.dockerUid = '1000'
if (project.hasProperty('docker.uid')) {
    ext.dockerUid = project.property('docker.uid')
}

ext.dockerCacheContainerName = 'xenon-test-cache-' + (java.util.UUID.randomUUID() as String)

//  DOCKER COMPOSE
// ================

task checkDockerComposePresence(type: Exec) {
    description "Whether docker compose is installed and accessible from gradle"
    executable 'docker-compose'
    args = ['-v']
    standardOutput = new ByteArrayOutputStream()
}

class DockerCompose extends Exec {
    def DockerCompose() {
        workingDir project.ext.dockerDir
        executable 'docker-compose'
        dependsOn project.tasks.checkDockerComposePresence
    }
}

task dockerKill(type: DockerCompose) {
    description "Stop Xenon Docker integrationTest containers"
    group 'Docker'
    args = ['kill']
}

task dockerCleanup(type: DockerCompose, dependsOn: dockerKill) {
    description "Remove Xenon Docker integrationTest containers"
    group 'Docker'
    args = ['rm', '-f']
}

task dockerIntegrationTest(type: DockerCompose, dependsOn: 'dockerTestCache') {
    // FIXME: the current version of docker-compose 1.4.2 does not
    // forward stdout if running from gradle (without TTY). Check if
    // future versions support this.
    description "Run integration tests using Docker containers as client and servers"
    group 'Verification'

    args = ['run', '--rm', '-e','BOOT_DELAY=15', '-e', 'MYUID=' + dockerUid, 'xenon-test']
    if (project.hasProperty('docker.tests')) {
        args += [
            './gradlew', 'integrationTest',
            '-Pxenon.test.properties=src/integrationTest/docker/xenon.test.properties.docker',
            '--project-cache-dir', '/home/xenon/gradle-cache',
            '--tests', project.property('docker.tests')
        ]
    }
    finalizedBy 'dockerCleanup'
}

//  DOCKER BUILD SETUP
// ====================

def dockerImageRequirementsSpec = copySpec {
    from('src/integrationTest/resources/scripts') {
        include 'create_symlinks'
    }
    from(dockerDir) {
        include 'insecure-ssh-keys/*'
    }
}
task dockerCopyAlpineRequirements(type: Copy) {
    with dockerImageRequirementsSpec
    into dockerDir + '/xenon-alpine-base'
}
task dockerCopyPhusionRequirements(type: Copy) {
    with dockerImageRequirementsSpec
    into dockerDir + '/xenon-phusion-base'
}
task dockerCopyTorqueRequirements(type: Copy) {
    with dockerImageRequirementsSpec
    into dockerDir + '/xenon-torque'
}

task dockerCopyRequirements(dependsOn: [
        dockerCopyAlpineRequirements,
        dockerCopyPhusionRequirements,
        dockerCopyTorqueRequirements
    ]) {
    description "Copy required files for building the docker containers."
}

//  DOCKER BUILD
// ==============

ext.testCacheSet = file('.docker-test-cache-set')

task checkDockerPresence(type: Exec) {
    description "Whether docker is installed and accessible from gradle"
    executable 'docker'
    args = ['version']
    standardOutput = new ByteArrayOutputStream()
}

task dockerTestCache(dependsOn: [checkDockerPresence]) {
    description "Cache gradle dependencies in xenon-test Docker container"
    def testCacheSet = file('.docker-test-cache-set')
    onlyIf {
        !testCacheSet.exists()
    }
    doLast {
        exec {
            commandLine 'docker', 'run', '-e', 'MYUID=' + dockerUid,
                '--name=' + dockerCacheContainerName, '-v', "$projectDir:/code",
                'nlesc/xenon-test', './gradlew', '--project-cache-dir',
                '/home/xenon/gradle-cache', 'downloadDependencies'
        }
        exec {
            commandLine 'docker', 'commit', dockerCacheContainerName,
                'nlesc/xenon-test'
        }
    }
    finalizedBy 'dockerMarkTestCacheSet', 'dockerTestCacheCleanup'
}

task dockerMarkTestCacheSet(type: Exec) {
	description "Avoid re-running test cache generation"
    group 'Docker'
    onlyIf {
        dockerTestCache.state.executed && !dockerTestCache.state.failure
    }
    outputs.file testCacheSet
    commandLine 'touch', testCacheSet.absolutePath
}

task resetDockerTestCache(type: Delete) {
	description "Re-run test cache generation"
    group 'Docker'
    delete testCacheSet
}

task dockerTestCacheCleanup(type: Exec, dependsOn: checkDockerPresence) {
    description "Remove temporary Docker cache container"
    group 'Docker'
    onlyIf {
        dockerTestCache.state.didWork
    }
    commandLine 'docker', 'rm', dockerCacheContainerName
}

task dockerBuild(dependsOn: [checkDockerPresence, resetDockerTestCache, dockerCopyRequirements]) << {
    println "Building docker images for: " + dockerImages
    dockerImages.each { image ->
        exec {
            workingDir dockerDir
            commandLine 'docker', 'build', '-t', 'nlesc/xenon-' + image, dockerDirectories[image]
        }
    }
}
dockerBuild.description = "Build Docker images from Dockerfile"
dockerBuild.group = 'Docker'

task dockerPush(dependsOn: checkDockerPresence) << {
    println "Pushing docker images of: " + dockerImages
    dockerImages.each { image ->
        exec {
            commandLine 'docker', 'push', 'nlesc/xenon-' + image
        }
    }
}
dockerPush.description = "Push Docker images to Dockerhub (run docker login first)"
dockerPush.group = 'Docker'

task dockerPull(dependsOn: checkDockerPresence) << {
    println "Pulling docker images of: " + dockerImages
    dockerImages.each { image ->
        exec {
            commandLine 'docker', 'pull', 'nlesc/xenon-' + image
        }
    }
}
dockerPull.description = "Pull Docker images from Dockerhub"
dockerPull.group = 'Docker'
